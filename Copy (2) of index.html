<!DOCTYPE html>
<html lang="ur" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø³ÛŒØ±Øª Ø§Ù„Ù†Ø¨ÛŒ ï·º - Ø¬Ø§Ù…Ø¹ Ø§Ù†ÙÙˆÚ¯Ø±Ø§ÙÚ© ØªØ§Ø±ÛŒØ®</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu:wght@400;700&display=swap');

        :root {
            --primary-color: #006778; /* Tealish Blue */
            --secondary-color: #0093AB; /* Lighter Teal */
            --accent-color: #FFD700; /* Gold/Yellow Accent */
            --text-color: #333333;
            --bg-color: #F0F8FF; /* Alice Blue - light background */
            --card-bg-color: #FFFFFF;
            --border-color: #D1E8E2; /* Light minty green */
            --header-bg: #004852;
            --header-text: #FFFFFF;
            --font-family-urdu: 'Noto Nastaliq Urdu', serif;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode {
            --primary-color: #0093AB;
            --secondary-color: #00C2CB;
            --accent-color: #FFEC8B;
            --text-color: #E0E0E0;
            --bg-color: #1A202C; /* Dark Slate Gray */
            --card-bg-color: #2D3748; /* Lighter Slate Gray */
            --border-color: #4A5568;
            --header-bg: #102a30;
            --header-text: #E0E0E0;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family-urdu);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.8;
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--header-bg);
            color: var(--header-text);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 3px solid var(--accent-color);
            margin-bottom: 20px;
        }

        header h1 {
            font-size: 1.8em;
            margin: 0;
        }

        .theme-toggle-btn {
            background-color: var(--accent-color);
            color: #333;
            border: none;
            padding: 8px 12px;
            font-family: var(--font-family-urdu);
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s;
        }
        body.dark-mode .theme-toggle-btn {
            background-color: var(--secondary-color);
            color: var(--header-text);
        }

        .controls, .navigation-tabs {
            background-color: var(--card-bg-color);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .controls input[type="text"],
        .controls select {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-family: var(--font-family-urdu);
            background-color: var(--bg-color);
            color: var(--text-color);
            min-width: 200px;
        }
        body.dark-mode .controls input[type="text"],
        body.dark-mode .controls select {
            background-color: #3e4c59;
        }


        .navigation-tabs button {
            padding: 10px 15px;
            font-family: var(--font-family-urdu);
            border: none;
            background-color: var(--secondary-color);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .navigation-tabs button.active,
        .navigation-tabs button:hover {
            background-color: var(--primary-color);
        }
        body.dark-mode .navigation-tabs button {
             background-color: var(--primary-color);
        }
        body.dark-mode .navigation-tabs button.active,
        body.dark-mode .navigation-tabs button:hover {
            background-color: var(--accent-color);
            color: #333;
        }


        .view { display: none; }
        .view.active { display: block; }

        #event-list-view .event-card {
            background-color: var(--card-bg-color);
            border-radius: 8px;
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: var(--box-shadow);
            border-right: 5px solid var(--primary-color);
            transition: transform 0.2s ease-in-out;
        }
        #event-list-view .event-card:hover {
            transform: translateY(-5px);
        }

        .event-card h3 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1.5em;
        }
        body.dark-mode .event-card h3 {
            color: var(--accent-color);
        }

        .event-card .meta-info {
            font-size: 0.9em;
            color: #777;
            margin-bottom: 10px;
        }
        body.dark-mode .event-card .meta-info { color: #aaa; }

        .event-card .meta-info span { margin-left: 15px; }
        .event-card .meta-info .icon { margin-right: 5px; } /* For potential icons */

        .event-card .short-detail {
            margin-bottom: 10px;
        }

        .event-card .tags span {
            background-color: var(--secondary-color);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.8em;
            margin-left: 5px;
            display: inline-block;
            margin-bottom: 5px;
        }
        body.dark-mode .event-card .tags span {
             background-color: var(--primary-color);
        }


        .event-card .actions button {
            background-color: var(--accent-color);
            color: #333;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: var(--font-family-urdu);
            margin-left: 10px;
            font-size: 0.9em;
        }
         body.dark-mode .event-card .actions button {
            background-color: var(--secondary-color);
            color: white;
        }


        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
        }
        .modal-content {
            background-color: var(--card-bg-color);
            margin: 5% auto;
            padding: 25px;
            border: 1px solid var(--border-color);
            width: 80%;
            max-width: 700px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }
        .close-btn {
            color: #aaa;
            float: left; /* RTL */
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-btn:hover, .close-btn:focus {
            color: var(--text-color);
            text-decoration: none;
        }
        #modal-event-title { color: var(--primary-color); margin-bottom: 15px; }
        body.dark-mode #modal-event-title { color: var(--accent-color); }
        .modal-section { margin-bottom: 15px; }
        .modal-section h4 { margin-bottom: 5px; color: var(--secondary-color); }
        body.dark-mode .modal-section h4 { color: var(--primary-color); }
        .modal-section ul { padding-right: 20px; }


        /* Timeline, Map, Charts Placeholder Styles */
        .infographic-placeholder {
            min-height: 300px;
            background-color: var(--card-bg-color);
            border: 2px dashed var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2em;
            color: #999;
            padding: 20px;
            border-radius: 8px;
            box-shadow: var(--box-shadow);
        }
        body.dark-mode .infographic-placeholder { color: #777; }

        /* Loading indicator */
        .loader {
            text-align: center;
            padding: 50px;
            font-size: 1.5em;
            color: var(--primary-color);
        }
         body.dark-mode .loader { color: var(--accent-color); }

        /* Utility */
        .hidden { display: none !important; }
        .text-center { text-align: center; }
        .narrative-path-selector { margin-bottom: 20px; }
        .narrative-path-selector label { margin-left: 10px; }


        /* Simple SVG Timeline attempt */
        #timeline-svg-container {
            width: 100%;
            overflow-x: auto;
            padding: 20px 0;
        }
        #timeline-svg {
            display: block;
            min-width: 1500px; /* Allow horizontal scrolling */
        }
        .timeline-axis {
            stroke: var(--text-color);
            stroke-width: 2;
        }
        .timeline-event-group:hover .timeline-event-circle {
            r: 8;
            fill: var(--accent-color);
        }
        .timeline-event-group:hover .timeline-event-text {
            font-weight: bold;
            fill: var(--primary-color);
        }
        body.dark-mode .timeline-event-group:hover .timeline-event-text {
            fill: var(--accent-color);
        }
        .timeline-event-circle {
            fill: var(--secondary-color);
            stroke: var(--primary-color);
            stroke-width: 1;
            cursor: pointer;
            transition: r 0.2s, fill 0.2s;
        }
        .timeline-event-text {
            font-family: var(--font-family-urdu);
            font-size: 12px;
            fill: var(--text-color);
            text-anchor: middle;
            cursor: pointer;
        }
        .timeline-period-rect {
            fill: var(--primary-color);
            opacity: 0.1;
        }
        .timeline-period-text {
            font-family: var(--font-family-urdu);
            font-size: 14px;
            fill: var(--primary-color);
            text-anchor: middle;
            font-weight: bold;
        }
        body.dark-mode .timeline-period-text { fill: var(--accent-color); }
        body.dark-mode .timeline-period-rect { fill: var(--accent-color); }


    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Ø³ÛŒØ±Øª Ø§Ù„Ù†Ø¨ÛŒ ï·º - Ø¬Ø§Ù…Ø¹ Ø§Ù†ÙÙˆÚ¯Ø±Ø§ÙÚ© ØªØ§Ø±ÛŒØ®</h1>
            <button id="themeToggleBtn" class="theme-toggle-btn">ÚˆØ§Ø±Ú© Ù…ÙˆÚˆ</button>
        </header>

        <div class="controls">
            <input type="text" id="searchInput" placeholder="ØªÙ„Ø§Ø´ Ú©Ø±ÛŒÚº (ÙˆØ§Ù‚Ø¹ÛØŒ ØªÙØµÛŒÙ„ØŒ Ø´Ø®ØµÛŒØªØŒ Ù¹ÛŒÚ¯)">
            <select id="filterPeriod">
                <option value="">ØªÙ…Ø§Ù… Ø§Ø¯ÙˆØ§Ø±</option>
                <option value="Ù‚Ø¨Ù„ Ø§Ø² Ù†Ø¨ÙˆØª">Ù‚Ø¨Ù„ Ø§Ø² Ù†Ø¨ÙˆØª</option>
                <option value="Ù†Ø¨ÙˆÛŒ">Ù†Ø¨ÙˆÛŒ (Ù…Ú©ÛŒ)</option>
                <option value="ÛØ¬Ø±ÛŒ">ÛØ¬Ø±ÛŒ (Ù…Ø¯Ù†ÛŒ)</option>
            </select>
            <select id="filterTag">
                <option value="">ØªÙ…Ø§Ù… Ù¹ÛŒÚ¯Ø²</option>
                <!-- Tags will be populated by JS -->
            </select>
            <select id="filterSignificance">
                <option value="">Ø§ÛÙ…ÛŒØª (ØªÙ…Ø§Ù…)</option>
                <option value="5">5 (Ø§Ù†ØªÛØ§Ø¦ÛŒ Ø§ÛÙ…)</option>
                <option value="4">4</option>
                <option value="3">3</option>
                <option value="2">2</option>
                <option value="1">1 (Ú©Ù… Ø§ÛÙ…)</option>
            </select>
        </div>

        <div class="navigation-tabs">
            <button class="tab-btn active" data-view="event-list-view">ÙÛØ±Ø³ØªÙ ÙˆØ§Ù‚Ø¹Ø§Øª</button>
            <button class="tab-btn" data-view="timeline-view">Ù¹Ø§Ø¦Ù… Ù„Ø§Ø¦Ù†</button>
            <button class="tab-btn" data-view="map-view">Ù†Ù‚Ø´Û</button>
            <button class="tab-btn" data-view="charts-view">Ø´Ù…Ø§Ø±ÛŒØ§Øª</button>
            <button class="tab-btn" data-view="narrative-paths-view">Ù…ÙˆØ¶ÙˆØ¹Ø§ØªÛŒ Ø³ÙØ±</button>
            <button class="tab-btn" data-view="glossary-view">Ø§ØµØ·Ù„Ø§Ø­Ø§Øª</button>
            <button class="tab-btn" data-view="bookmarks-view">Ù¾Ø³Ù†Ø¯ÛŒØ¯Û</button>
        </div>
        
        <div id="narrative-paths-view" class="view narrative-path-selector">
            <label for="narrativePathSelect">Ø§ÛŒÚ© Ù…ÙˆØ¶ÙˆØ¹Ø§ØªÛŒ Ø³ÙØ± Ù…Ù†ØªØ®Ø¨ Ú©Ø±ÛŒÚº:</label>
            <select id="narrativePathSelect">
                <option value="">- Ù…Ù†ØªØ®Ø¨ Ú©Ø±ÛŒÚº -</option>
                <option value="hijrat">ÛØ¬Ø±Øª Ú©Ø§ Ø³ÙØ±</option>
                <option value="treaties">Ø§ÛÙ… Ù…Ø¹Ø§ÛØ¯Û’</option>
                <option value="battles">Ø§ÛÙ… ØºØ²ÙˆØ§Øª</option>
                 <!-- More paths can be added -->
            </select>
            <div id="narrative-path-content" class="infographic-placeholder">Ù…ÙˆØ¶ÙˆØ¹Ø§ØªÛŒ Ù…ÙˆØ§Ø¯ ÛŒÛØ§Úº Ø¸Ø§ÛØ± ÛÙˆÚ¯Ø§</div>
        </div>


        <div id="event-list-view" class="view active">
            <!-- Event cards will be dynamically inserted here -->
            <div class="loader">ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆ ÛÙˆ Ø±ÛØ§ ÛÛ’...</div>
        </div>

        <div id="timeline-view" class="view">
             <div id="timeline-svg-container">
                <svg id="timeline-svg" height="400"></svg>
            </div>
            <div class="infographic-placeholder hidden">Ù¹Ø§Ø¦Ù… Ù„Ø§Ø¦Ù† Ù„ÙˆÚˆ ÛÙˆ Ø±ÛÛŒ ÛÛ’...</div>
        </div>

        <div id="map-view" class="view">
            <div class="infographic-placeholder">Ù†Ù‚Ø´Û’ Ú©ÛŒ Ø®ØµÙˆØµÛŒØª Ø¬Ù„Ø¯ Ø¢Ø±ÛÛŒ ÛÛ’Û” (Ø¬ÛŒÙˆ Ø§Ø³Ù¾ÛŒØ´Ù„ ÚˆÛŒÙ¹Ø§ Ù¾Ø± Ù…Ø¨Ù†ÛŒ)</div>
        </div>

        <div id="charts-view" class="view">
            <div class="infographic-placeholder">Ø´Ù…Ø§Ø±ÛŒØ§ØªÛŒ Ú†Ø§Ø±Ù¹ Ø¬Ù„Ø¯ Ø¢Ø±ÛÛ’ ÛÛŒÚºÛ”</div>
        </div>

        <div id="glossary-view" class="view">
            <div class="infographic-placeholder">Ø§ÛÙ… Ø§ØµØ·Ù„Ø§Ø­Ø§Øª Ú©ÛŒ ÙÛØ±Ø³Øª Ø¬Ù„Ø¯ Ø¢Ø±ÛÛŒ ÛÛ’Û”</div>
        </div>
        <div id="bookmarks-view" class="view">
             <div id="bookmarked-events-list"></div>
            <div class="infographic-placeholder hidden">Ú©ÙˆØ¦ÛŒ Ù¾Ø³Ù†Ø¯ÛŒØ¯Û ÙˆØ§Ù‚Ø¹Û Ù…ÙˆØ¬ÙˆØ¯ Ù†ÛÛŒÚºÛ”</div>
        </div>

    </div>

    <!-- Event Detail Modal -->
    <div id="eventDetailModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="closeModalBtn">Ã—</span>
            <h2 id="modal-event-title"></h2>
            <div class="modal-section">
                <h4>Ø¯ÙˆØ±Ø§Ù†ÛŒÛ:</h4>
                <p id="modal-event-period"></p>
            </div>
            <div class="modal-section">
                <h4>Ø¹ÛŒØ³ÙˆÛŒ ØªØ§Ø±ÛŒØ®:</h4>
                <p id="modal-event-gregorian-year"></p>
            </div>
            <div class="modal-section">
                <h4>Ù…Ø®ØªØµØ± ØªÙØµÛŒÙ„:</h4>
                <p id="modal-event-short-detail"></p>
            </div>
            <div class="modal-section">
                <h4>ØªÙØµÛŒÙ„ÛŒ ÙˆØ¶Ø§Ø­Øª:</h4>
                <p id="modal-event-long-detail"></p>
            </div>
            <div class="modal-section">
                <h4>Ú©Ù„ÛŒØ¯ÛŒ Ù†Ú©Ø§Øª (Ø§Ù†ÙÙˆÚ¯Ø±Ø§ÙÚ©):</h4>
                <ul id="modal-event-infographic-points"></ul>
            </div>
            <div class="modal-section">
                <h4>Ù…ØªØ¹Ù„Ù‚Û Ø´Ø®ØµÛŒØ§Øª:</h4>
                <p id="modal-event-personalities"></p>
            </div>
            <div class="modal-section">
                <h4>Ù…Ù‚Ø§Ù…:</h4>
                <p id="modal-event-location"></p>
            </div>
            <div class="modal-section">
                <h4>Ø§ÛÙ…ÛŒØª:</h4>
                <p id="modal-event-significance"></p>
            </div>
            <div class="modal-section">
                <h4>Ù¹ÛŒÚ¯Ø²:</h4>
                <div id="modal-event-tags" class="tags"></div>
            </div>
             <div class="modal-section">
                <h4>ØªØµÙˆÛŒØ±ÛŒ Ø­ÙˆØ§Ù„Û:</h4>
                <p id="modal-event-image-ref">(Ø§Ù…ÛŒØ¬ ÚˆØ³Ù¾Ù„Û’ ÛŒÛØ§Úº Ø¢Ø¦Û’ Ú¯Ø§)</p>
            </div>
        </div>
    </div>

    <script>
    // --- Constants ---
    const DB_NAME = 'SeerahInfographicDB_v1';
    const STORE_NAME = 'enriched_events';
    const DB_VERSION = 1;
    let db;
    let allEventsData = []; // To hold all events in memory for filtering/searching

    // --- DOM Elements ---
    const searchInput = document.getElementById('searchInput');
    const filterPeriodSelect = document.getElementById('filterPeriod');
    const filterTagSelect = document.getElementById('filterTag');
    const filterSignificanceSelect = document.getElementById('filterSignificance');
    const eventListView = document.getElementById('event-list-view');
    const themeToggleBtn = document.getElementById('themeToggleBtn');
    const modal = document.getElementById('eventDetailModal');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const tabButtons = document.querySelectorAll('.tab-btn');
    const views = document.querySelectorAll('.view');
    const narrativePathSelect = document.getElementById('narrativePathSelect');
    const bookmarkedEventsList = document.getElementById('bookmarked-events-list');
    const timelineSvgContainer = document.getElementById('timeline-svg-container');
    const timelineSvg = document.getElementById('timeline-svg');

    // --- IndexedDB Functions ---
    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = (event) => reject("IndexedDB Ø®Ø±Ø§Ø¨ÛŒ: " + event.target.errorCode);
            request.onsuccess = (event) => {
                db = event.target.result;
                resolve(db);
            };
            request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'Ø´Ù…Ø§Ø±' });
                }
            };
        });
    }

    function addDataToDB(dataArray) {
        return new Promise((resolve, reject) => {
            if (!db) { reject("DB not initialized"); return; }
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            let operations = dataArray.length;
            if (operations === 0) resolve();

            dataArray.forEach(item => {
                const request = store.put(item); // put will add or update
                request.onsuccess = () => {
                    operations--;
                    if (operations === 0) resolve();
                };
                request.onerror = (event) => reject("ÚˆÛŒÙ¹Ø§ Ø´Ø§Ù…Ù„ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ø®Ø±Ø§Ø¨ÛŒ: " + event.target.error);
            });
            transaction.oncomplete = () => resolve();
            transaction.onerror = (event) => reject("Ù¹Ø±Ø§Ù†Ø²ÛŒÚ©Ø´Ù† Ø®Ø±Ø§Ø¨ÛŒ: " + event.target.error);
        });
    }
    
    function updateEventInDB(eventData) {
        return addDataToDB([eventData]); // `put` handles update
    }


    function getAllDataFromDB() {
        return new Promise((resolve, reject) => {
            if (!db) { reject("DB not initialized"); return; }
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();
            request.onsuccess = (event) => resolve(event.target.result);
            request.onerror = (event) => reject("ÚˆÛŒÙ¹Ø§ Ø­Ø§ØµÙ„ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ø®Ø±Ø§Ø¨ÛŒ: " + event.target.error);
        });
    }

    // --- CSV Parsing ---
    function parseCSV(csvText) {
        const lines = csvText.trim().split('\n');
        if (lines.length < 2) return []; // Need header and at least one data row
        const headers = lines[0].trim().split(',').map(h => h.trim());
        const data = [];
        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].trim().split(',');
            if (values.length === headers.length) {
                const entry = {};
                headers.forEach((header, index) => {
                    entry[header] = values[index] ? values[index].trim() : '';
                });
                data.push(entry);
            }
        }
        return data;
    }

    async function fetchAndParseCSV(filePath) {
        try {
            const response = await fetch(filePath);
            if (!response.ok) {
                if (response.status === 404 && (filePath.includes('historyupdate.csv') || filePath.includes('details.csv')) ) {
                    console.log(`${filePath} Ù†ÛÛŒÚº Ù…Ù„ÛŒØŒ Ù†Ø¸Ø± Ø§Ù†Ø¯Ø§Ø² Ú©ÛŒØ§ Ø¬Ø§ Ø±ÛØ§ ÛÛ’Û”`);
                    return []; // Okay if update or details file not found
                }
                throw new Error(`ÙØ§Ø¦Ù„ ${filePath} Ù„ÙˆÚˆ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ${response.statusText}`);
            }
            const csvText = await response.text();
            return parseCSV(csvText);
        } catch (error) {
            console.error(error.message);
            if (filePath.includes('historyupdate.csv') || filePath.includes('details.csv')) return [];
            throw error; // Re-throw for critical files like history.csv
        }
    }

    // --- Data Loading and Processing ---
    async function loadInitialData() {
        try {
            await openDB();
            const existingData = await getAllDataFromDB();
            if (existingData && existingData.length > 0) {
                console.log("Ù…ÙˆØ¬ÙˆØ¯Û ÚˆÛŒÙ¹Ø§ IndexedDB Ø³Û’ Ù„ÙˆÚˆ Ú©ÛŒØ§ Ú¯ÛŒØ§Û”");
                allEventsData = existingData;
                await loadUpdateData(); // Check for updates even if existing data is present
                return;
            }

            console.log("Ø§Ø¨ØªØ¯Ø§Ø¦ÛŒ ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆ Ú©ÛŒØ§ Ø¬Ø§ Ø±ÛØ§ ÛÛ’...");
            const historyData = await fetchAndParseCSV('history.csv');
            const detailsDataArray = await fetchAndParseCSV('details.csv');
            
            if (!historyData || historyData.length === 0) {
                eventListView.innerHTML = '<p class="text-center">Ø§Ø¨ØªØ¯Ø§Ø¦ÛŒ ØªØ§Ø±ÛŒØ® Ú©ÛŒ ÙØ§Ø¦Ù„ (history.csv) Ù„ÙˆÚˆ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒÛ”</p>';
                return;
            }

            const detailsMap = new Map();
            detailsDataArray.forEach(detail => detailsMap.set(detail['Ø´Ù…Ø§Ø±'], detail));

            const enrichedData = historyData.map(event => {
                const details = detailsMap.get(event['Ø´Ù…Ø§Ø±']) || {};
                return { ...event, ...details, isBookmarked: false }; // Add bookmark flag
            });

            await addDataToDB(enrichedData);
            allEventsData = enrichedData;
            console.log("Ø§Ø¨ØªØ¯Ø§Ø¦ÛŒ ÚˆÛŒÙ¹Ø§ Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ù„ÙˆÚˆ Ø§ÙˆØ± Ø§Ø³Ù¹ÙˆØ± Ú©ÛŒØ§ Ú¯ÛŒØ§Û”");
            await loadUpdateData();

        } catch (error) {
            console.error("Ø§Ø¨ØªØ¯Ø§Ø¦ÛŒ ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆÙ†Ú¯ Ù…ÛŒÚº Ø®Ø±Ø§Ø¨ÛŒ:", error);
            eventListView.innerHTML = `<p class="text-center">ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ø®Ø±Ø§Ø¨ÛŒ: ${error.message}</p>`;
        }
    }

    async function loadUpdateData() {
        try {
            console.log("Ø§Ù¾ ÚˆÛŒÙ¹ ÙØ§Ø¦Ù„ Ú†ÛŒÚ© Ú©ÛŒ Ø¬Ø§ Ø±ÛÛŒ ÛÛ’...");
            const updateData = await fetchAndParseCSV('historyupdate.csv');
            if (updateData && updateData.length > 0) {
                // Assuming updateData does not have corresponding details in this flow
                // For simplicity, new events from update.csv get default empty detail fields
                const newEnrichedUpdateData = updateData.map(event => ({
                    ...event, 
                    ØªÙØµÛŒÙ„ÛŒ_ÙˆØ¶Ø§Ø­Øª: '', 
                    Ù…ØªØ¹Ù„Ù‚Û_Ø´Ø®ØµÛŒØ§Øª: '',
                    Ù…Ù‚Ø§Ù…: '',
                    Ù†Ù‚Ø´Û_Ú©ÙˆØ¢Ø±ÚˆÛŒÙ†ÛŒÙ¹Ø³: '',
                    Ø§ÛÙ…ÛŒØª_Ø§Ø³Ú©ÙˆØ±: event['Ø§ÛÙ…ÛŒØª_Ø§Ø³Ú©ÙˆØ±'] || '3', // Default if not present
                    ØªØµÙˆÛŒØ±ÛŒ_Ø­ÙˆØ§Ù„Û: '',
                    Ù¹ÛŒÚ¯Ø²: event['Ù¹ÛŒÚ¯Ø²'] || '',
                    Ú©Ù„ÛŒØ¯ÛŒ_Ù†Ú©Ø§Øª_Ø§Ù†ÙÙˆÚ¯Ø±Ø§ÙÚ©: '',
                    isBookmarked: false
                }));

                await addDataToDB(newEnrichedUpdateData);
                console.log(`${newEnrichedUpdateData.length} Ø§Ù¾ ÚˆÛŒÙ¹ Ø´Ø¯Û ÙˆØ§Ù‚Ø¹Ø§Øª Ø´Ø§Ù…Ù„ Ú©ÛŒÛ’ Ú¯Ø¦Û’Û”`);
                // Refresh allEventsData from DB to include updates
                allEventsData = await getAllDataFromDB();
            } else {
                console.log("Ú©ÙˆØ¦ÛŒ Ù†Ø¦ÛŒ Ø§Ù¾ ÚˆÛŒÙ¹ ÙØ§Ø¦Ù„ Ù†ÛÛŒÚº Ù…Ù„ÛŒÛ”");
            }
        } catch (error) {
            console.error("Ø§Ù¾ ÚˆÛŒÙ¹ ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆÙ†Ú¯ Ù…ÛŒÚº Ø®Ø±Ø§Ø¨ÛŒ:", error);
        }
    }
    

    // --- UI Rendering Functions ---
    function renderEventList(events) {
        eventListView.innerHTML = ''; // Clear previous list
        if (!events || events.length === 0) {
            eventListView.innerHTML = '<p class="text-center">Ú©ÙˆØ¦ÛŒ ÙˆØ§Ù‚Ø¹Ø§Øª Ù†ÛÛŒÚº Ù…Ù„Û’Û”</p>';
            return;
        }

        const fragment = document.createDocumentFragment();
        events.forEach(event => {
            const card = document.createElement('div');
            card.className = 'event-card';
            card.dataset.id = event['Ø´Ù…Ø§Ø±'];

            const title = document.createElement('h3');
            title.textContent = event['ÙˆØ§Ù‚Ø¹Û (Ø§Ø±Ø¯Ùˆ)'] || 'N/A';

            const metaInfo = document.createElement('div');
            metaInfo.className = 'meta-info';
            metaInfo.innerHTML = `
                <span><span class="icon">ğŸ“…</span> ${event['Ø¹ÛŒØ³ÙˆÛŒ Ø³Ø§Ù„ (ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹)'] || 'N/A'}</span>
                <span><span class="icon">â³</span> ${event['ÛØ¬Ø±ÛŒ Ø³Ø§Ù„ / Ø¯ÙˆØ±'] || 'N/A'}</span>
                ${event['Ø§ÛÙ…ÛŒØª_Ø§Ø³Ú©ÙˆØ±'] ? `<span><span class="icon">â­</span> Ø§ÛÙ…ÛŒØª: ${event['Ø§ÛÙ…ÛŒØª_Ø§Ø³Ú©ÙˆØ±']}</span>` : ''}
            `;

            const shortDetail = document.createElement('p');
            shortDetail.className = 'short-detail';
            shortDetail.textContent = event['Ù…Ø®ØªØµØ± ØªÙØµÛŒÙ„ (Ø§Ø±Ø¯Ùˆ)'] || '';
            
            const tagsContainer = document.createElement('div');
            tagsContainer.className = 'tags';
            if (event['Ù¹ÛŒÚ¯Ø²']) {
                event['Ù¹ÛŒÚ¯Ø²'].split('|').forEach(tag => { // Assuming tags are pipe-separated
                    const tagSpan = document.createElement('span');
                    tagSpan.textContent = tag.trim();
                    tagsContainer.appendChild(tagSpan);
                });
            }


            const actions = document.createElement('div');
            actions.className = 'actions';
            const detailButton = document.createElement('button');
            detailButton.textContent = 'Ù…Ø²ÛŒØ¯ ØªÙØµÛŒÙ„Ø§Øª';
            detailButton.onclick = () => showEventDetailModal(event['Ø´Ù…Ø§Ø±']);
            
            const bookmarkButton = document.createElement('button');
            bookmarkButton.textContent = event.isBookmarked ? 'Ù¾Ø³Ù†Ø¯ÛŒØ¯Û Ø³Û’ ÛÙ¹Ø§Ø¦ÛŒÚº' : 'Ù¾Ø³Ù†Ø¯ÛŒØ¯Û Ø¨Ù†Ø§Ø¦ÛŒÚº';
            bookmarkButton.className = 'bookmark-btn';
            bookmarkButton.onclick = (e) => {
                e.stopPropagation(); // Prevent card click if any
                toggleBookmark(event['Ø´Ù…Ø§Ø±']);
            };

            actions.appendChild(detailButton);
            actions.appendChild(bookmarkButton);

            card.appendChild(title);
            card.appendChild(metaInfo);
            card.appendChild(shortDetail);
            card.appendChild(tagsContainer);
            card.appendChild(actions);
            fragment.appendChild(card);
        });
        eventListView.appendChild(fragment);
    }

    function showEventDetailModal(eventId) {
        const event = allEventsData.find(e => e['Ø´Ù…Ø§Ø±'] === eventId);
        if (!event) return;

        document.getElementById('modal-event-title').textContent = event['ÙˆØ§Ù‚Ø¹Û (Ø§Ø±Ø¯Ùˆ)'] || 'N/A';
        document.getElementById('modal-event-period').textContent = event['ÛØ¬Ø±ÛŒ Ø³Ø§Ù„ / Ø¯ÙˆØ±'] || 'N/A';
        document.getElementById('modal-event-gregorian-year').textContent = event['Ø¹ÛŒØ³ÙˆÛŒ Ø³Ø§Ù„ (ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹)'] || 'N/A';
        document.getElementById('modal-event-short-detail').textContent = event['Ù…Ø®ØªØµØ± ØªÙØµÛŒÙ„ (Ø§Ø±Ø¯Ùˆ)'] || 'N/A';
        document.getElementById('modal-event-long-detail').textContent = event['ØªÙØµÛŒÙ„ÛŒ ÙˆØ¶Ø§Ø­Øª'] || 'Ú©ÙˆØ¦ÛŒ ØªÙØµÛŒÙ„ÛŒ ÙˆØ¶Ø§Ø­Øª Ø¯Ø³ØªÛŒØ§Ø¨ Ù†ÛÛŒÚºÛ”';
        
        const infographicPointsList = document.getElementById('modal-event-infographic-points');
        infographicPointsList.innerHTML = '';
        if (event['Ú©Ù„ÛŒØ¯ÛŒ_Ù†Ú©Ø§Øª_Ø§Ù†ÙÙˆÚ¯Ø±Ø§ÙÚ©']) {
            event['Ú©Ù„ÛŒØ¯ÛŒ_Ù†Ú©Ø§Øª_Ø§Ù†ÙÙˆÚ¯Ø±Ø§ÙÚ©'].split('|').forEach(point => {
                const li = document.createElement('li');
                li.textContent = point.trim();
                infographicPointsList.appendChild(li);
            });
        } else {
            infographicPointsList.innerHTML = '<li>Ú©ÙˆØ¦ÛŒ Ú©Ù„ÛŒØ¯ÛŒ Ù†Ú©Ø§Øª Ø¯Ø³ØªÛŒØ§Ø¨ Ù†ÛÛŒÚºÛ”</li>';
        }

        document.getElementById('modal-event-personalities').textContent = event['Ù…ØªØ¹Ù„Ù‚Û Ø´Ø®ØµÛŒØ§Øª'] || 'N/A';
        document.getElementById('modal-event-location').textContent = event['Ù…Ù‚Ø§Ù…'] || 'N/A';
        document.getElementById('modal-event-significance').textContent = event['Ø§ÛÙ…ÛŒØª_Ø§Ø³Ú©ÙˆØ±'] ? `${event['Ø§ÛÙ…ÛŒØª_Ø§Ø³Ú©ÙˆØ±']} / 5` : 'N/A';
        
        const modalTagsContainer = document.getElementById('modal-event-tags');
        modalTagsContainer.innerHTML = '';
         if (event['Ù¹ÛŒÚ¯Ø²']) {
            event['Ù¹ÛŒÚ¯Ø²'].split('|').forEach(tag => {
                const tagSpan = document.createElement('span');
                tagSpan.textContent = tag.trim();
                modalTagsContainer.appendChild(tagSpan);
            });
        }

        document.getElementById('modal-event-image-ref').textContent = event['ØªØµÙˆÛŒØ±ÛŒ_Ø­ÙˆØ§Ù„Û'] || 'Ú©ÙˆØ¦ÛŒ ØªØµÙˆÛŒØ±ÛŒ Ø­ÙˆØ§Ù„Û Ù†ÛÛŒÚºÛ”';

        modal.style.display = 'block';
    }
    
    function renderTimeline(events) {
        // Simplified SVG Timeline - this needs significant improvement for a real app
        timelineSvg.innerHTML = ''; // Clear previous
        if (!events || events.length === 0) {
            document.getElementById('timeline-view').querySelector('.infographic-placeholder').classList.remove('hidden');
            return;
        }
        document.getElementById('timeline-view').querySelector('.infographic-placeholder').classList.add('hidden');

        const PADDING = 50;
        const SVG_HEIGHT = 400;
        const EVENT_RADIUS = 5;
        const YEAR_STEP = 1; // How many years per "tick" - adjust for density

        // Sort events by approximate Gregorian year for timeline plotting
        const sortedEvents = [...events].sort((a, b) => {
            const yearA = parseInt(a['Ø¹ÛŒØ³ÙˆÛŒ Ø³Ø§Ù„ (ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹)']);
            const yearB = parseInt(b['Ø¹ÛŒØ³ÙˆÛŒ Ø³Ø§Ù„ (ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹)']);
            return yearA - yearB;
        });
        
        if (sortedEvents.length === 0) return;

        const firstYear = parseInt(sortedEvents[0]['Ø¹ÛŒØ³ÙˆÛŒ Ø³Ø§Ù„ (ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹)']);
        const lastYear = parseInt(sortedEvents[sortedEvents.length - 1]['Ø¹ÛŒØ³ÙˆÛŒ Ø³Ø§Ù„ (ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹)']);
        const yearRange = lastYear - firstYear || 1; // Avoid division by zero

        // Dynamically set SVG width based on year range and density
        const estimatedWidth = Math.max(1500, yearRange * 20 + 2 * PADDING); // Min width or calculated
        timelineSvg.setAttribute('width', estimatedWidth);
        timelineSvg.setAttribute('height', SVG_HEIGHT);


        // Main axis line
        const axis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        axis.setAttribute('x1', PADDING);
        axis.setAttribute('y1', SVG_HEIGHT / 2);
        axis.setAttribute('x2', estimatedWidth - PADDING);
        axis.setAttribute('y2', SVG_HEIGHT / 2);
        axis.setAttribute('class', 'timeline-axis');
        timelineSvg.appendChild(axis);

        // Render Periods (conceptual)
        const periods = {
            "Ù‚Ø¨Ù„ Ø§Ø² Ù†Ø¨ÙˆØª": { start: 570, end: 609, color: "rgba(0, 103, 120, 0.1)" },
            "Ù†Ø¨ÙˆÛŒ": { start: 610, end: 621, color: "rgba(0, 147, 171, 0.1)" },
            "ÛØ¬Ø±ÛŒ": { start: 622, end: 632, color: "rgba(255, 215, 0, 0.1)" }
        };

        for (const periodName in periods) {
            const period = periods[periodName];
            const periodStartYear = period.start;
            const periodEndYear = period.end;

            const xStart = PADDING + ((periodStartYear - firstYear) / yearRange) * (estimatedWidth - 2 * PADDING);
            const xWidth = ((periodEndYear - periodStartYear) / yearRange) * (estimatedWidth - 2 * PADDING);
            
            if (xWidth > 0) {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', xStart);
                rect.setAttribute('y', PADDING / 2);
                rect.setAttribute('width', xWidth);
                rect.setAttribute('height', SVG_HEIGHT - PADDING);
                rect.setAttribute('fill', period.color);
                rect.setAttribute('class', 'timeline-period-rect');
                timelineSvg.appendChild(rect);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', xStart + xWidth / 2);
                text.setAttribute('y', PADDING - 10);
                text.setAttribute('class', 'timeline-period-text');
                text.textContent = periodName;
                timelineSvg.appendChild(text);
            }
        }


        // Plot events
        let yOffsetAlternate = 0; // To alternate event text position
        sortedEvents.forEach((event, index) => {
            const eventYear = parseInt(event['Ø¹ÛŒØ³ÙˆÛŒ Ø³Ø§Ù„ (ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹)']);
            if (isNaN(eventYear)) return;

            const x = PADDING + ((eventYear - firstYear) / yearRange) * (estimatedWidth - 2 * PADDING);
            const yBase = SVG_HEIGHT / 2;
            
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'timeline-event-group');
            group.onclick = () => showEventDetailModal(event['Ø´Ù…Ø§Ø±']);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', yBase);
            circle.setAttribute('r', EVENT_RADIUS);
            circle.setAttribute('class', 'timeline-event-circle');
            
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            const textY = yBase + (yOffsetAlternate % 2 === 0 ? -15 : 25) + ( (yOffsetAlternate / 2) % 3 * 10); // Basic staggering
            text.setAttribute('y', textY);
            text.setAttribute('class', 'timeline-event-text');
            text.textContent = `${event['ÙˆØ§Ù‚Ø¹Û (Ø§Ø±Ø¯Ùˆ)'].substring(0,15)}... (${eventYear})`;

            group.appendChild(circle);
            group.appendChild(text);
            timelineSvg.appendChild(group);
            yOffsetAlternate++;
        });
    }


    function populateFilterTags(events) {
        const tags = new Set();
        events.forEach(event => {
            if (event['Ù¹ÛŒÚ¯Ø²']) {
                event['Ù¹ÛŒÚ¯Ø²'].split('|').forEach(tag => tags.add(tag.trim()));
            }
        });
        filterTagSelect.innerHTML = '<option value="">ØªÙ…Ø§Ù… Ù¹ÛŒÚ¯Ø²</option>'; // Reset
        tags.forEach(tag => {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = tag;
            filterTagSelect.appendChild(option);
        });
    }

    // --- Filtering and Searching ---
    function applyFiltersAndSearch() {
        const searchTerm = searchInput.value.toLowerCase();
        const selectedPeriod = filterPeriodSelect.value;
        const selectedTag = filterTagSelect.value;
        const selectedSignificance = filterSignificanceSelect.value;

        let filteredEvents = allEventsData.filter(event => {
            const matchesSearch = !searchTerm ||
                (event['ÙˆØ§Ù‚Ø¹Û (Ø§Ø±Ø¯Ùˆ)'] && event['ÙˆØ§Ù‚Ø¹Û (Ø§Ø±Ø¯Ùˆ)'].toLowerCase().includes(searchTerm)) ||
                (event['Ù…Ø®ØªØµØ± ØªÙØµÛŒÙ„ (Ø§Ø±Ø¯Ùˆ)'] && event['Ù…Ø®ØªØµØ± ØªÙØµÛŒÙ„ (Ø§Ø±Ø¯Ùˆ)'].toLowerCase().includes(searchTerm)) ||
                (event['ØªÙØµÛŒÙ„ÛŒ ÙˆØ¶Ø§Ø­Øª'] && event['ØªÙØµÛŒÙ„ÛŒ ÙˆØ¶Ø§Ø­Øª'].toLowerCase().includes(searchTerm)) ||
                (event['Ù…ØªØ¹Ù„Ù‚Û Ø´Ø®ØµÛŒØ§Øª'] && event['Ù…ØªØ¹Ù„Ù‚Û Ø´Ø®ØµÛŒØ§Øª'].toLowerCase().includes(searchTerm)) ||
                (event['Ù¹ÛŒÚ¯Ø²'] && event['Ù¹ÛŒÚ¯Ø²'].toLowerCase().includes(searchTerm));

            const matchesPeriod = !selectedPeriod || (event['ÛØ¬Ø±ÛŒ Ø³Ø§Ù„ / Ø¯ÙˆØ±'] && event['ÛØ¬Ø±ÛŒ Ø³Ø§Ù„ / Ø¯ÙˆØ±'].includes(selectedPeriod));
            const matchesTag = !selectedTag || (event['Ù¹ÛŒÚ¯Ø²'] && event['Ù¹ÛŒÚ¯Ø²'].includes(selectedTag));
            const matchesSignificance = !selectedSignificance || (event['Ø§ÛÙ…ÛŒØª_Ø§Ø³Ú©ÙˆØ±'] && event['Ø§ÛÙ…ÛŒØª_Ø§Ø³Ú©ÙˆØ±'] === selectedSignificance);
            
            return matchesSearch && matchesPeriod && matchesTag && matchesSignificance;
        });
        
        // Update current view with filtered events
        const activeViewId = document.querySelector('.view.active').id;
        if (activeViewId === 'event-list-view' || document.querySelector('#narrative-paths-view.active')) { // For narrative view as well
             renderEventList(filteredEvents);
        } else if (activeViewId === 'timeline-view') {
            renderTimeline(filteredEvents);
        } else if (activeViewId === 'bookmarks-view') {
            renderBookmarks(); // Re-render bookmarks based on current allEventsData and filters
        }
        // Add similar logic for map and charts if they use filtered data
    }
    
    function filterForNarrativePath(pathKey) {
        let narrativeEvents = [];
        // This is a very basic implementation. Real narrative paths would need more complex logic or specific tags.
        switch(pathKey) {
            case 'hijrat':
                narrativeEvents = allEventsData.filter(e => 
                    (e['ÙˆØ§Ù‚Ø¹Û (Ø§Ø±Ø¯Ùˆ)'] && e['ÙˆØ§Ù‚Ø¹Û (Ø§Ø±Ø¯Ùˆ)'].includes('ÛØ¬Ø±Øª')) || 
                    (e['Ù¹ÛŒÚ¯Ø²'] && e['Ù¹ÛŒÚ¯Ø²'].includes('ÛØ¬Ø±Øª'))
                );
                break;
            case 'treaties':
                narrativeEvents = allEventsData.filter(e => e['Ù¹ÛŒÚ¯Ø²'] && e['Ù¹ÛŒÚ¯Ø²'].includes('Ù…Ø¹Ø§ÛØ¯Û'));
                break;
            case 'battles':
                narrativeEvents = allEventsData.filter(e => e['Ù¹ÛŒÚ¯Ø²'] && (e['Ù¹ÛŒÚ¯Ø²'].includes('ØºØ²ÙˆÛ') || e['Ù¹ÛŒÚ¯Ø²'].includes('Ø¬Ù†Ú¯')));
                break;
            default:
                narrativeEvents = allEventsData; // Show all if no path or unknown path
        }
        document.getElementById('narrative-path-content').classList.add('hidden');
        eventListView.innerHTML = ''; // Clear event list view content area if it's not the target
        renderEventList(narrativeEvents); // Render into the default list view for now
    }


    // --- Theme Toggle ---
    function toggleTheme() {
        document.body.classList.toggle('dark-mode');
        const isDarkMode = document.body.classList.contains('dark-mode');
        localStorage.setItem('seerahInfographicTheme', isDarkMode ? 'dark' : 'light');
        themeToggleBtn.textContent = isDarkMode ? 'Ù„Ø§Ø¦Ù¹ Ù…ÙˆÚˆ' : 'ÚˆØ§Ø±Ú© Ù…ÙˆÚˆ';
    }

    function applySavedTheme() {
        const savedTheme = localStorage.getItem('seerahInfographicTheme');
        if (savedTheme === 'dark') {
            document.body.classList.add('dark-mode');
            themeToggleBtn.textContent = 'Ù„Ø§Ø¦Ù¹ Ù…ÙˆÚˆ';
        } else {
             themeToggleBtn.textContent = 'ÚˆØ§Ø±Ú© Ù…ÙˆÚˆ';
        }
    }
    
    // --- Bookmarking ---
    async function toggleBookmark(eventId) {
        const eventIndex = allEventsData.findIndex(e => e['Ø´Ù…Ø§Ø±'] === eventId);
        if (eventIndex === -1) return;

        allEventsData[eventIndex].isBookmarked = !allEventsData[eventIndex].isBookmarked;
        try {
            await updateEventInDB(allEventsData[eventIndex]);
            applyFiltersAndSearch(); // Re-render to update button text and bookmarks view if active
            if(document.querySelector('#bookmarks-view.active')) {
                renderBookmarks();
            }
        } catch (error) {
            console.error("Ø¨Ú© Ù…Ø§Ø±Ú© Ø§Ù¾ ÚˆÛŒÙ¹ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ø®Ø±Ø§Ø¨ÛŒ:", error);
            // Revert UI change if DB update fails (optional)
            allEventsData[eventIndex].isBookmarked = !allEventsData[eventIndex].isBookmarked;
        }
    }

    function renderBookmarks() {
        const bookmarked = allEventsData.filter(event => event.isBookmarked);
        bookmarkedEventsList.innerHTML = '';
        const placeholder = document.querySelector('#bookmarks-view .infographic-placeholder');
        if (bookmarked.length === 0) {
            placeholder.classList.remove('hidden');
            return;
        }
        placeholder.classList.add('hidden');
        renderEventListToContainer(bookmarked, bookmarkedEventsList); // Use a helper to render cards
    }
    
    // Helper to render event cards to a specific container
    function renderEventListToContainer(events, container) {
        container.innerHTML = ''; // Clear previous list
        const fragment = document.createDocumentFragment();
        events.forEach(event => {
            const card = document.createElement('div');
            card.className = 'event-card'; // Re-use existing card style
            card.dataset.id = event['Ø´Ù…Ø§Ø±'];

            const title = document.createElement('h3');
            title.textContent = event['ÙˆØ§Ù‚Ø¹Û (Ø§Ø±Ø¯Ùˆ)'] || 'N/A';

            const metaInfo = document.createElement('div');
            metaInfo.className = 'meta-info';
            metaInfo.innerHTML = `<span>${event['Ø¹ÛŒØ³ÙˆÛŒ Ø³Ø§Ù„ (ØªÙ‚Ø±ÛŒØ¨Ø§Ù‹)'] || 'N/A'}</span> | <span>${event['ÛØ¬Ø±ÛŒ Ø³Ø§Ù„ / Ø¯ÙˆØ±'] || 'N/A'}</span>`;
            
            const actions = document.createElement('div');
            actions.className = 'actions';
            const detailButton = document.createElement('button');
            detailButton.textContent = 'Ù…Ø²ÛŒØ¯ ØªÙØµÛŒÙ„Ø§Øª';
            detailButton.onclick = () => showEventDetailModal(event['Ø´Ù…Ø§Ø±']);
            
            const unbookmarkButton = document.createElement('button');
            unbookmarkButton.textContent = 'Ù¾Ø³Ù†Ø¯ÛŒØ¯Û Ø³Û’ ÛÙ¹Ø§Ø¦ÛŒÚº';
            unbookmarkButton.onclick = (e) => {
                e.stopPropagation();
                toggleBookmark(event['Ø´Ù…Ø§Ø±']);
            };

            actions.appendChild(detailButton);
            actions.appendChild(unbookmarkButton);

            card.appendChild(title);
            card.appendChild(metaInfo);
            card.appendChild(actions);
            fragment.appendChild(card);
        });
        container.appendChild(fragment);
    }


    // --- Event Listeners and Initialization ---
    document.addEventListener('DOMContentLoaded', async () => {
        applySavedTheme();
        await loadInitialData();
        if (allEventsData && allEventsData.length > 0) {
            renderEventList(allEventsData); // Initial render
            populateFilterTags(allEventsData);
            renderTimeline(allEventsData); // Also render initial timeline
        } else {
             eventListView.innerHTML = '<div class="loader">Ú©ÙˆØ¦ÛŒ ÙˆØ§Ù‚Ø¹Ø§Øª Ù„ÙˆÚˆ Ù†ÛÛŒÚº ÛÙˆØ¦Û’Û” Ø¨Ø±Ø§Û Ú©Ø±Ù… CSV ÙØ§Ø¦Ù„ÛŒÚº Ú†ÛŒÚ© Ú©Ø±ÛŒÚºÛ”</div>';
        }

        searchInput.addEventListener('input', applyFiltersAndSearch);
        filterPeriodSelect.addEventListener('change', applyFiltersAndSearch);
        filterTagSelect.addEventListener('change', applyFiltersAndSearch);
        filterSignificanceSelect.addEventListener('change', applyFiltersAndSearch);
        themeToggleBtn.addEventListener('click', toggleTheme);
        closeModalBtn.onclick = () => modal.style.display = 'none';
        window.onclick = (event) => {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        };
        
        narrativePathSelect.addEventListener('change', (e) => {
            if (e.target.value) {
                 // Switch to event list view for narrative path display if not already active
                views.forEach(v => v.classList.remove('active'));
                tabButtons.forEach(b => b.classList.remove('active'));
                
                eventListView.classList.add('active');
                document.querySelector('.tab-btn[data-view="event-list-view"]').classList.add('active'); // Visually activate list tab
                // Also hide the placeholder in narrative path view itself
                document.getElementById('narrative-path-content').classList.add('hidden');
                filterForNarrativePath(e.target.value);
            } else {
                 document.getElementById('narrative-path-content').classList.remove('hidden');
                 document.getElementById('narrative-path-content').innerHTML = "Ù…ÙˆØ¶ÙˆØ¹Ø§ØªÛŒ Ù…ÙˆØ§Ø¯ ÛŒÛØ§Úº Ø¸Ø§ÛØ± ÛÙˆÚ¯Ø§";
                 applyFiltersAndSearch(); // Show all/filtered events if no path selected
            }
        });


        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                const viewId = button.dataset.view;
                views.forEach(view => {
                    view.classList.remove('active');
                    if (view.id === viewId) {
                        view.classList.add('active');
                    }
                });
                // Special rendering logic for views if needed when tab is clicked
                if (viewId === 'timeline-view') renderTimeline(allEventsData); // Re-render with all data or filtered data
                if (viewId === 'bookmarks-view') renderBookmarks();
                if (viewId === 'event-list-view') applyFiltersAndSearch(); // Apply current filters to list view
                if (viewId === 'narrative-paths-view') {
                     // Reset narrative path selector and content
                    narrativePathSelect.value = '';
                    document.getElementById('narrative-path-content').classList.remove('hidden');
                    document.getElementById('narrative-path-content').innerHTML = "Ù…ÙˆØ¶ÙˆØ¹Ø§ØªÛŒ Ù…ÙˆØ§Ø¯ ÛŒÛØ§Úº Ø¸Ø§ÛØ± ÛÙˆÚ¯Ø§";
                }
            });
        });
    });

    </script>
</body>
</html>